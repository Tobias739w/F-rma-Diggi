<!DOCTYPE html> <html lang="de"> <head> <meta charset="UTF-8" /> <meta name="viewport" content="width=device-width, initial-scale=1.0" /> <title>Snake-Spiel</title> <style> :root { --bg: #111820; --fg: #e9f0f5; --snake: #4cd964; --food: #ff6b6b; --grid: 20px; } html, body { height: 100%; margin: 0; background: var(--bg); color: var(--fg); font-family: Arial, sans-serif; display: flex; align-items: center; justify-content: center; } .container { text-align: center; width: min(90vw, 720px); } canvas { border: 2px solid #334; background: #0a0f1a; image-rendering: pixelated; } .info { margin-top: 12px; } .btn { padding: 8px 14px; margin: 6px; border: none; border-radius: 6px; background: #1e88e5; color: white; cursor: pointer; font-weight: bold; } .btn.secondary { background: #2e2e2e; } .score { font-size: 1.1em; margin-top: 6px; } </style> </head> <body> <div class="container"> <h1>Snake-Spiel</h1> <canvas id="game" width="640" height="480" tabindex="0" aria-label="Snake Spiel"></canvas> <div class="info"> <button class="btn" id="startBtn" title="Spiel starten">Start</button> <button class="btn secondary" id="pauseBtn" title="Pausieren/Weiter">Pause</button> <button class="btn secondary" id="resetBtn" title="Neues Spiel">Neu</button> </div> <div class="score" id="score">Punktestand: 0</div> </div> <script> // Spiel-Konstanten const canvas = document.getElementById('game'); const ctx = canvas.getContext('2d'); const gridSize = 20; // Größe einer Zelle const cols = canvas.width / gridSize; const rows = canvas.height / gridSize; // Spielfelder let snake = []; let dir = { x: 1, y: 0 }; // Start-Richtung nach rechts let nextDir = { x: 1, y: 0 }; let food = { x: 0, y: 0 }; let growing = 0; let running = false; let intervalId = null; let score = 0; // Init-Funktionen function resetGame() { snake = []; // Start-Schlange in Mitte const startX = Math.floor(cols / 2); const startY = Math.floor(rows / 2); snake.push({ x: startX, y: startY }); snake.push({ x: startX - 1, y: startY }); snake.push({ x: startX - 2, y: startY }); dir = { x: 1, y: 0 }; nextDir = { x: 1, y: 0 }; score = 0; growing = 0; placeFood(); updateScore(); } function placeFood() { // Zufällige Position, die nicht auf der Schlange liegt let empty = []; for (let y = 0; y < rows; y++) { for (let x = 0; x < cols; x++) { if (!snake.some(s => s.x === x && s.y === y)) { empty.push({ x, y }); } } } if (empty.length === 0) { // Gewonnen? food = null; return; } food = empty[Math.floor(Math.random() * empty.length)]; } function drawCell(x, y, color) { ctx.fillStyle = color; ctx.fillRect(x * gridSize, y * gridSize, gridSize, gridSize); } function render() { // Hintergrund ctx.fillStyle = '#0a0f1a'; ctx.fillRect(0, 0, canvas.width, canvas.height); // Schlange zeichnen for (let i = 0; i < snake.length; i++) { const s = snake[i]; const isHead = i === 0; drawCell(s.x, s.y, isHead ? '#9be24d' : '#4cd964'); } // Nahrung zeichnen if (food) { drawCell(food.x, food.y, '#ff6b6b'); } // HUD-Rand (optional) // (kannst du hinzufügen, wenn du magst) } function update() { // Richtung übernehmen dir = { ...nextDir }; // Nächste Kopfposition const head = snake[0]; const newHead = { x: head.x + dir.x, y: head.y + dir.y }; // Rand-/Kollision prüfen (Wand) if (newHead.x < 0 || newHead.y < 0 || newHead.x >= cols || newHead.y >= rows) { stopGame(); return; } // Selbst-Kollision prüfen if (snake.some(seg => seg.x === newHead.x && seg.y === newHead.y)) { stopGame(); return; } // Schlange verschieben snake.unshift(newHead); // Essen fressen? if (food && newHead.x === food.x && newHead.y === food.y) { score += 10; growing += 1; placeFood(); updateScore(); } if (growing > 0) { growing--; } else { snake.pop(); } render(); } function updateScore() { document.getElementById('score').textContent = 'Punktestand: ' + score; } function startGame() { if (intervalId) return; running = true; intervalId = setInterval(update, 140); } function stopGame() { running = false; if (intervalId) { clearInterval(intervalId); intervalId = null; } // Kurze Meldung (optional) // alert('Spiel vorbei! Dein Punktestand: ' + score); } // Tastatur-Steuerung window.addEventListener('keydown', (e) => { const key = e.key; // Pfeile oder WASD let newDir = null; if (key === 'ArrowUp' || key === 'w' || key === 'W') newDir = { x: 0, y: -1 }; else if (key === 'ArrowDown' || key === 's' || key === 'S') newDir = { x: 0, y: 1 }; else if (key === 'ArrowLeft' || key === 'a' || key === 'A') newDir = { x: -1, y: 0 }; else if (key === 'ArrowRight' || key === 'd' || key === 'D') newDir = { x: 1, y: 0 }; if (newDir) { // Vermeide Rückwärtsgang if (snake.length > 1 && (newDir.x === -dir.x && newDir.y === -dir.y)) return; // nur gültige Richtungen übernehmen if ((newDir.x !== 0 && dir.y !== newDir.y) || (newDir.y !== 0 && dir.x !== newDir.x)) { nextDir = newDir; } else if (newDir.x !== 0 || newDir.y !== 0) { nextDir = newDir; } } // Space zum Start/Pause if (key === ' ' || key === 'Spacebar') { e.preventDefault(); if (running) { stopGame(); } else { startGame(); } } }); // Button-Verknüpfungen document.getElementById('startBtn').addEventListener('click', () => { if (!running) { startGame(); } }); document.getElementById('pauseBtn').addEventListener('click', () => { if (running) { stopGame(); } else { startGame(); } }); document.getElementById('resetBtn').addEventListener('click', () => { stopGame(); resetGame(); render(); }); // Initialisierung resetGame(); render(); // Canvas Fokus, damit Tastatursteuerung funktioniert canvas.focus(); </script> </body> </html>
